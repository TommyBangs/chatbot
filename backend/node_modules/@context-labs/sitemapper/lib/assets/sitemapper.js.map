{"version":3,"file":"sitemapper.js","names":["Sitemapper","constructor","options","settings","requestHeaders","url","timeout","timeoutTable","lastmod","debug","concurrency","retries","rejectUnauthorized","fetch","a","arguments","b","_asyncToGenerator","length","results","sites","errors","console","concat","crawl","e","error","duration","timestamp","option","parse","requestOptions","method","resolveWithFullResponse","gzip","responseType","headers","https","requester","got","get","initializeTimeout","response","statusCode","clearTimeout","data","responseBody","isGzip","rawBody","decompressResponseBody","body","parseStringPromise","name","message","setTimeout","cancel","c","retryIndex","log","type","urlset","filter","site","modified","Date","getTime","map","loc","sitemapindex","sitemap","limit","pLimit","promiseArray","Promise","all","result","reduce","prev","getSites","callback","warn","err","resolve","reject","buffer","Buffer","from","zlib","gunzip","exports","default","module"],"sources":["../../src/assets/sitemapper.js"],"sourcesContent":["/**\n * Sitemap Parser\n *\n * Copyright (c) 2020 Sean Thomas Burke\n * Licensed under the MIT license.\n * @author Sean Burke <@seantomburke>\n */\n\nimport { parseStringPromise } from \"xml2js\";\nimport got from \"got\";\nimport zlib from \"zlib\";\nimport pLimit from \"p-limit\";\nimport isGzip from \"is-gzip\";\n\n/**\n * @typedef {Object} Sitemapper\n */\nexport default class Sitemapper {\n  /**\n   * Construct the Sitemapper class\n   *\n   * @params {Object} options to set\n   * @params {string} [options.url] - the Sitemap url (e.g https://wp.seantburke.com/sitemap.xml)\n   * @params {Timeout} [options.timeout] - @see {timeout}\n   * @params {boolean} [options.debug] - Enables/Disables additional logging\n   * @params {integer} [options.concurrency] - The number of concurrent sitemaps to crawl (e.g. 2 will crawl no more than 2 sitemaps at the same time)\n   * @params {integer} [options.retries] - The maximum number of retries to attempt when crawling fails (e.g. 1 for 1 retry, 2 attempts in total)\n   * @params {boolean} [options.rejectUnauthorized] - If true (default), it will throw on invalid certificates, such as expired or self-signed ones.\n   * @params {lastmod} [options.lastmod] - the minimum lastmod value for urls\n   *\n   * @example let sitemap = new Sitemapper({\n   *   url: 'https://wp.seantburke.com/sitemap.xml',\n   *   timeout: 15000,\n   *   lastmod: 1630693759\n   *  });\n   */\n  constructor(options) {\n    const settings = options || { requestHeaders: {} };\n    this.url = settings.url;\n    this.timeout = settings.timeout || 15000;\n    this.timeoutTable = {};\n    this.lastmod = settings.lastmod || 0;\n    this.requestHeaders = settings.requestHeaders;\n    this.debug = settings.debug;\n    this.concurrency = settings.concurrency || 10;\n    this.retries = settings.retries || 0;\n    this.rejectUnauthorized =\n      settings.rejectUnauthorized === false ? false : true;\n  }\n\n  /**\n   * Gets the sites from a sitemap.xml with a given URL\n   *\n   * @public\n   * @param {string} [url] - the Sitemaps url (e.g https://wp.seantburke.com/sitemap.xml)\n   * @returns {Promise<SitesData>}\n   * @example sitemapper.fetch('example.xml')\n   *  .then((sites) => console.log(sites));\n   */\n  async fetch(url = this.url) {\n    // initialize empty variables\n    let results = {\n      url: \"\",\n      sites: [],\n      errors: [],\n    };\n\n    // attempt to set the variables with the crawl\n    if (this.debug) {\n      // only show if it's set\n      if (this.lastmod) {\n        console.debug(`Using minimum lastmod value of ${this.lastmod}`);\n      }\n    }\n\n    try {\n      // crawl the URL\n      results = await this.crawl(url);\n    } catch (e) {\n      // show errors that may occur\n      if (this.debug) {\n        console.error(e);\n      }\n    }\n\n    return {\n      url,\n      sites: results.sites || [],\n      errors: results.errors || [],\n    };\n  }\n  /**\n   * Get the timeout\n   *\n   * @example console.log(sitemapper.timeout);\n   * @returns {Timeout}\n   */\n  static get timeout() {\n    return this.timeout;\n  }\n\n  /**\n   * Set the timeout\n   *\n   * @public\n   * @param {Timeout} duration\n   * @example sitemapper.timeout = 15000; // 15 seconds\n   */\n  static set timeout(duration) {\n    this.timeout = duration;\n  }\n\n  /**\n   * Get the lastmod minimum value\n   *\n   * @example console.log(sitemapper.lastmod);\n   * @returns {Number}\n   */\n  static get lastmod() {\n    return this.lastmod;\n  }\n\n  /**\n   * Set the lastmod minimum value\n   *\n   * @public\n   * @param {Number} timestamp\n   * @example sitemapper.lastmod = 1630694181; // Unix timestamp\n   */\n  static set lastmod(timestamp) {\n    this.lastmod = timestamp;\n  }\n\n  /**\n   *\n   * @param {string} url - url for making requests. Should be a link to a sitemaps.xml\n   * @example sitemapper.url = 'https://wp.seantburke.com/sitemap.xml'\n   */\n  static set url(url) {\n    this.url = url;\n  }\n\n  /**\n   * Get the url to parse\n   * @returns {string}\n   * @example console.log(sitemapper.url)\n   */\n  static get url() {\n    return this.url;\n  }\n\n  /**\n   * Setter for the debug state\n   * @param {Boolean} option - set whether to show debug logs in output.\n   * @example sitemapper.debug = true;\n   */\n  static set debug(option) {\n    this.debug = option;\n  }\n\n  /**\n   * Getter for the debug state\n   * @returns {Boolean}\n   * @example console.log(sitemapper.debug)\n   */\n  static get debug() {\n    return this.debug;\n  }\n\n  /**\n   * Requests the URL and uses parseStringPromise to parse through and find the data\n   *\n   * @private\n   * @param {string} [url] - the Sitemaps url (e.g https://wp.seantburke.com/sitemap.xml)\n   * @returns {Promise<ParseData>}\n   */\n  async parse(url = this.url) {\n    // setup the response options for the got request\n    const requestOptions = {\n      method: \"GET\",\n      resolveWithFullResponse: true,\n      gzip: true,\n      responseType: \"buffer\",\n      headers: this.requestHeaders,\n      https: {\n        rejectUnauthorized: this.rejectUnauthorized,\n      },\n    };\n\n    try {\n      // create a request Promise with the url and request options\n      const requester = got.get(url, requestOptions);\n\n      // initialize the timeout method based on the URL, and pass the request object.\n      this.initializeTimeout(url, requester);\n\n      // get the response from the requester promise\n      const response = await requester;\n\n      // if the response does not have a successful status code then clear the timeout for this url.\n      if (!response || response.statusCode !== 200) {\n        clearTimeout(this.timeoutTable[url]);\n        return { error: response.error, data: response };\n      }\n\n      let responseBody;\n\n      if (isGzip(response.rawBody)) {\n        responseBody = await this.decompressResponseBody(response.body);\n      } else {\n        responseBody = response.body;\n      }\n\n      // otherwise parse the XML that was returned.\n      const data = await parseStringPromise(responseBody);\n\n      // return the results\n      return { error: null, data };\n    } catch (error) {\n      // If the request was canceled notify the user of the timeout\n      if (error.name === \"CancelError\") {\n        return {\n          error: `Request timed out after ${this.timeout} milliseconds for url: '${url}'`,\n          data: error,\n        };\n      }\n\n      // If an HTTPError include error http code\n      if (error.name === \"HTTPError\") {\n        return {\n          error: `HTTP Error occurred: ${error.message}`,\n          data: error,\n        };\n      }\n\n      // Otherwise notify of another error\n      return {\n        error: `Error occurred: ${error.name}`,\n        data: error,\n      };\n    }\n  }\n\n  /**\n   * Timeouts are necessary for large xml trees. This will cancel the call if the request is taking\n   * too long, but will still allow the promises to resolve.\n   *\n   * @private\n   * @param {string} url - url to use as a hash in the timeoutTable\n   * @param {Promise} requester - the promise that creates the web request to the url\n   */\n  initializeTimeout(url, requester) {\n    // this will throw a CancelError which will be handled in the parent that calls this method.\n    this.timeoutTable[url] = setTimeout(() => requester.cancel(), this.timeout);\n  }\n\n  /**\n   * Recursive function that will go through a sitemaps tree and get all the sites\n   *\n   * @private\n   * @recursive\n   * @param {string} url - the Sitemaps url (e.g https://wp.seantburke.com/sitemap.xml)\n   * @param {integer} retryIndex - Number of retry attempts fro this URL (e.g. 0 for 1st attempt, 1 for second attempty etc.)\n   * @returns {Promise<SitesData>}\n   */\n  async crawl(url, retryIndex = 0) {\n    try {\n      const { error, data } = await this.parse(url);\n      // The promise resolved, remove the timeout\n      clearTimeout(this.timeoutTable[url]);\n\n      if (error) {\n        // Handle errors during sitemap parsing / request\n        // Retry on error until you reach the retry limit set in the settings\n        if (retryIndex < this.retries) {\n          if (this.debug) {\n            console.log(\n              `(Retry attempt: ${retryIndex + 1} / ${\n                this.retries\n              }) ${url} due to ${data.name} on previous request`\n            );\n          }\n          return this.crawl(url, retryIndex + 1);\n        }\n\n        if (this.debug) {\n          console.error(\n            `Error occurred during \"crawl('${url}')\":\\n\\r Error: ${error}`\n          );\n        }\n\n        // Fail and log error\n        return {\n          sites: [],\n          errors: [\n            {\n              type: data.name,\n              message: error,\n              url,\n              retries: retryIndex,\n            },\n          ],\n        };\n      } else if (data && data.urlset && data.urlset.url) {\n        // Handle URLs found inside the sitemap\n        if (this.debug) {\n          console.debug(`Urlset found during \"crawl('${url}')\"`);\n        }\n        // filter out any urls that are older than the lastmod\n        const sites = data.urlset.url\n          .filter((site) => {\n            if (this.lastmod === 0) return true;\n            if (site.lastmod === undefined) return false;\n            const modified = new Date(site.lastmod[0]).getTime();\n\n            return modified >= this.lastmod;\n          })\n          .map((site) => site.loc && site.loc[0]);\n        return {\n          sites,\n          errors: [],\n        };\n      } else if (data && data.sitemapindex) {\n        // Handle child sitemaps found inside the active sitemap\n        if (this.debug) {\n          console.debug(`Additional sitemap found during \"crawl('${url}')\"`);\n        }\n        // Map each child url into a promise to create an array of promises\n        const sitemap = data.sitemapindex.sitemap.map(\n          (map) => map.loc && map.loc[0]\n        );\n\n        // Parse all child urls within the concurrency limit in the settings\n        const limit = pLimit(this.concurrency);\n        const promiseArray = sitemap.map((site) =>\n          limit(() => this.crawl(site))\n        );\n\n        // Make sure all the promises resolve then filter and reduce the array\n        const results = await Promise.all(promiseArray);\n        const sites = results\n          .filter((result) => result.errors.length === 0)\n          .reduce((prev, { sites }) => [...prev, ...sites], []);\n        const errors = results\n          .filter((result) => result.errors.length !== 0)\n          .reduce((prev, { errors }) => [...prev, ...errors], []);\n\n        return {\n          sites,\n          errors,\n        };\n      }\n\n      // Retry on error until you reach the retry limit set in the settings\n      if (retryIndex < this.retries) {\n        if (this.debug) {\n          console.log(\n            `(Retry attempt: ${retryIndex + 1} / ${\n              this.retries\n            }) ${url} due to ${data.name} on previous request`\n          );\n        }\n        return this.crawl(url, retryIndex + 1);\n      }\n      if (this.debug) {\n        console.error(`Unknown state during \"crawl('${url})'\":`, error, data);\n      }\n\n      // Fail and log error\n      return {\n        sites: [],\n        errors: [\n          {\n            url,\n            type: data.name || \"UnknownStateError\",\n            message: \"An unknown error occurred.\",\n            retries: retryIndex,\n          },\n        ],\n      };\n    } catch (e) {\n      if (this.debug) {\n        this.debug && console.error(e);\n      }\n    }\n  }\n\n  /**\n   * Gets the sites from a sitemap.xml with a given URL\n   *\n   * @deprecated\n   * @param {string} url - url to query\n   * @param {getSitesCallback} callback - callback for sites and error\n   * @callback\n   */\n  async getSites(url = this.url, callback) {\n    console.warn(\n      // eslint-disable-line no-console\n      \"\\r\\nWarning:\",\n      \"function .getSites() is deprecated, please use the function .fetch()\\r\\n\"\n    );\n\n    let err = {};\n    let sites = [];\n    try {\n      const response = await this.fetch(url);\n      sites = response.sites;\n    } catch (error) {\n      err = error;\n    }\n    return callback(err, sites);\n  }\n\n  /**\n   * Decompress the gzipped response body using zlib.gunzip\n   *\n   * @param {Buffer} body - body of the gzipped file\n   * @returns {Boolean}\n   */\n  decompressResponseBody(body) {\n    return new Promise((resolve, reject) => {\n      const buffer = Buffer.from(body);\n      zlib.gunzip(buffer, (err, result) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(result);\n        }\n      });\n    });\n  }\n}\n\n/**\n * Callback for the getSites method\n *\n * @callback getSitesCallback\n * @param {Object} error - error from callback\n * @param {Array} sites - an Array of sitemaps\n */\n\n/**\n * Timeout in milliseconds\n *\n * @typedef {Number} Timeout\n * the number of milliseconds before all requests timeout. The promises will still resolve so\n * you'll still receive parts of the request, but maybe not all urls\n * default is 15000 which is 15 seconds\n */\n\n/**\n * Resolve handler type for the promise in this.parse()\n *\n * @typedef {Object} ParseData\n *\n * @property {Error} error that either comes from `parseStringPromise` or `got` or custom error\n * @property {Object} data\n * @property {string} data.url - URL of sitemap\n * @property {Array} data.urlset - Array of returned URLs\n * @property {string} data.urlset.url - single Url\n * @property {Object} data.sitemapindex - index of sitemap\n * @property {string} data.sitemapindex.sitemap - Sitemap\n * @example {\n *   error: 'There was an error!'\n *   data: {\n *     url: 'https://linkedin.com',\n *     urlset: [{\n *       url: 'https://www.linkedin.com/project1'\n *     },[{\n *       url: 'https://www.linkedin.com/project2'\n *     }]\n *   }\n * }\n */\n\n/**\n * Resolve handler type for the promise in this.parse()\n *\n * @typedef {Object} SitesData\n *\n * @property {string} url - the original url used to query the data\n * @property {SitesArray} sites\n * @property {ErrorDataArray} errors\n * @example {\n *   url: 'https://linkedin.com/sitemap.xml',\n *   sites: [\n *     'https://linkedin.com/project1',\n *     'https://linkedin.com/project2'\n *   ],\n *   errors: [\n *      {\n *        type: 'CancelError',\n *        url: 'https://www.walmart.com/sitemap_tp1.xml',\n *        retries: 0\n *      },\n *      {\n *        type: 'HTTPError',\n *        url: 'https://www.walmart.com/sitemap_tp2.xml',\n *        retries: 0\n *      },\n *   ]\n * }\n */\n\n/**\n * An array of urls\n *\n * @typedef {String[]} SitesArray\n * @example [\n *   'https://www.google.com',\n *   'https://www.linkedin.com'\n * ]\n */\n\n/**\n * An array of Error data objects\n *\n * @typedef {ErrorData[]} ErrorDataArray\n * @example [\n *    {\n *      type: 'CancelError',\n *      url: 'https://www.walmart.com/sitemap_tp1.xml',\n *      retries: 0\n *    },\n *    {\n *      type: 'HTTPError',\n *      url: 'https://www.walmart.com/sitemap_tp2.xml',\n *      retries: 0\n *    },\n * ]\n */\n\n/**\n * An object containing details about the errors which occurred during the crawl\n *\n * @typedef {Object} ErrorData\n *\n * @property {string} type - The error type which was returned\n * @property {string} url - The sitemap URL which returned the error\n * @property {Number} errors - The total number of retries attempted after receiving the first error\n * @example {\n *    type: 'CancelError',\n *    url: 'https://www.walmart.com/sitemap_tp1.xml',\n *    retries: 0\n * }\n */\n"],"mappings":"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"}