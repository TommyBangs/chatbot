"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function formatBytes(bytes, decimals = 2) {
    if (!+bytes)
        return '0 Bytes';
    const k = 1024;
    const dm = decimals < 0 ? 0 : decimals;
    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return `${parseFloat((bytes / Math.pow(k, i)).toFixed(dm))} ${sizes[i]}`;
}
const formatDuration = (duration) => {
    // return new Date((duration ?? 0) * 1000).toISOString().slice(11, 19);
    const h = Math.floor(duration / 3600);
    const m = Math.floor((duration % 3600) / 60);
    const s = Math.floor((duration % 3600) % 60);
    const hDisplay = h > 0 ? h + (h === 1 ? 'hr ' : 'hrs ') : '';
    const mDisplay = m > 0 ? m + (m === 1 ? 'm ' : 'm ') : '';
    const sDisplay = s > 0 ? s + (s === 1 ? 's' : 's') : '';
    if (h === 0) {
        return hDisplay + mDisplay + sDisplay;
    }
    return hDisplay + mDisplay;
};
const totalDuration = (files) => {
    return files.reduce((acc, file) => { var _a; return acc + ((_a = file === null || file === void 0 ? void 0 : file.durationSeconds) !== null && _a !== void 0 ? _a : 0); }, 0);
};
const calculatePrice = (duration) => {
    const hours = duration / 3600;
    const roundedHours = Math.ceil(hours);
    return String(Number(roundedHours * 3).toFixed(2));
};
const calculateStripeCheckoutQuantity = (duration) => {
    const hours = duration / 3600;
    const roundedHours = Math.ceil(hours);
    return Number(roundedHours);
};
const NinjaUtil = {
    formatBytes,
    formatDuration,
    totalDuration,
    calculatePrice,
    calculateStripeCheckoutQuantity,
};
exports.default = NinjaUtil;
//# sourceMappingURL=NinjaUtil.js.map